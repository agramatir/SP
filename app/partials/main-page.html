<div layout="row">
  
  <div flex="30">
  <md-button data-ng-click="rollback()" >
      Д
  </md-button>
  	<treecontrol class="tree-light"
	   tree-model="data"
	   options="treeOptions"
	   on-selection="showOptions(node, selected)"
	   expanded-nodes="expandedNodes">
	   <md-button ng-class="{'md-raised md-primary': equality(node, selectedNode)}">{{bnf[node.label].label || node.label}}</md-button>
	</treecontrol>
  </div>
  <div flex></div>
  <div flex="25" data-ng-show="showContext">
  	<h3>Виберіть дію</h3>
  	<md-radio-group ng-model="selectedOption">
      <md-radio-button ng-repeat="option in context"
                       ng-value="option">
          <span data-ng-repeat="(key, el) in option track by $index">{{bnf[el].label}} </span>
      </md-radio-button>
    </md-radio-group>
    <md-button data-ng-click="addNodes()" flex="100" class="md-raised md-warn">
    	Добавити
	</md-button>
  </div>
  <div flex="30" data-ng-show="showEditContext">
  	<md-input-container>
        <label>Введіть значення</label>
        <input type="text" ng-model="valueNodeLabel">
     </md-input-container>
    <md-button data-ng-click="addValue()" flex="100" class="md-raised md-warn">
    	Добавити
	</md-button>
  </div>
  
<div layout="column" flex="45">
	<md-switch ng-model="showProgramText" aria-label="Switch" id="code-graph-toggle">
	    Переключити режим
	 </md-switch>
	  <div  id="help-info-for-rendering" ng-show="false">{{data}}</div>


    <svg id="svg-canvas" class="main-svg" ng-show="!showProgramText" style="height: 100%"></svg>


  <div id="program-code" style="font-size:25px;" ng-show="showProgramText">
    
  </div>

	</div>
</div>



<script>


  var writeProgramCode = function(data) {
    var data = JSON.parse(data);
    var writeNode = function(node,parentJQuery,depth) {
      var s = "";
      if (node.children.length==0)
        s = node.label;
      var div = $("<span>").html(s+" ");
      parentJQuery.append(div);

      //console.log([node.label,parentJQuery.html()]);

      for (var i = 0; i < node.children.length; ++i) {
        var qqqwer = depth+1;
        writeNode(node.children[i],div,qqqwer);
      }
      if (node.label.search("statement") != -1) {
        div.before("<br/>");
        div.attr("style","padding-left: "+depth+"em;");
      }
      if (node.label.search("end") != -1) {
        div.before("<br/>");
      }

      if (node.label.search("number") != -1) {
        div.attr("style",div.attr("style")+";color:purple;");
      }

      if (node.type == "terminal") {
        div.attr("style",div.attr("style")+";font-weight: bold;");
      }

    }

    data.forEach(function (node) {
      writeNode(node,$("#program-code"),0);
    });
  }

  var renderGraph = function(data) {
        var data = JSON.parse(data);
        $("#svg-canvas").empty();

        
        var nodes = {};
        var edges = [];


        var populate = function(vertex, nodes, edges) {
          var nodeID = Object.keys(nodes).length;

          var newNode = {
            label: vertex.label,
            id: nodeID + ""
          };

          var classes = [];
          if (vertex.type) {
            classes.push("node-type-" + vertex.type);
          }

          newNode.nodeclass = classes.join(" ");

          nodes[nodeID] = newNode;

          vertex.children.forEach(function (child) {
            var newChild = populate(child, nodes, edges);

            edges.push({
              source: newNode.id,
              target: newChild.id,
              id: newNode.id + "-" + newChild.id
            });

          });

          return newNode;
        }

        data.forEach(function (e) {
          populate(e, nodes, edges);
        });

        var g = new dagreD3.graphlib.Graph()
            .setGraph({})
            .setDefaultEdgeLabel(function () {
              return {};
            });

        for (var key in nodes) {
          var node = nodes[key];
          g.setNode(node.id, {
            label: node.label,
            class: node.nodeclass,
            //  round edges
            rx: 5,
            ry: 5
          });
        }

        edges.forEach(function (e) {
          g.setEdge(e.source, e.target, {
            lineTension: .8,
            lineInterpolate: "bundle"
          });
        });

        var render = new dagreD3.render();

        var svg = d3.select("#svg-canvas"),
            svgGroup = svg.append("g");

        render(d3.select("#svg-canvas g"), g);

        var xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
        svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
        svg.attr("height", g.graph().height + 40);

        //  enable zoom and scrolling
        svgGroup.attr("transform", "translate(5, 5)");
        svg.call(d3.behavior.zoom().on("zoom", function redraw() {
          svgGroup.attr("transform",
              "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
        }));
  }

        
        $("#code-graph-toggle").click(function(){
          setTimeout(function(){ 
          var data = $("#help-info-for-rendering").html();
          renderGraph(data);
          $("#program-code").html("");
          writeProgramCode(data);
        }, 20);
        });

      $("#help-info-for-rendering").bind("DOMSubtreeModified",function(){
      	setTimeout(function(){ 
      		var data = $("#help-info-for-rendering").html();
      		renderGraph(data);
	        $("#program-code").html("");
	        writeProgramCode(data);
      	}, 100);
     
      });
  

</script>



